
@startuml

interface CompletionController {
    associatedtype Success
    Completion is Fallible<<Success>>
}

interface Completing {
    func onComplete()
    func mapCompletion()
}

interface Completable {
    func complete()
}

interface UpdatesController {
    associatedtype Update
}

interface Updating {
    func onUpdate()
    func mapUpdate()
}

interface Updatable {
    func update()
}

interface EventsController {
    typealias Event = ChannelEvent<<Update, Success>>
}

interface EventsSource {
}

interface EventsDestination {
}

abstract class Future
class ConstantFuture {
    - init(completion:)
}
class Promise {
    + init()
}
abstract class Channel
abstract class BaseProducer
class ProducerProxy {
    + init(updateExecutor:updateHandler:)
}
class Producer {
    + init()
}
class Sink {
    + init(updateExecutor:updateHandler:)
}

CompletionController <|.. Completing
CompletionController <|.. Completable

UpdatesController <|.. Updating
UpdatesController <|.. Updatable

CompletionController <|.. EventsController
UpdatesController <|.. EventsController

EventsController <|.. EventsSource
EventsController <|.. EventsDestination

Updating <|.. EventsSource
Completing <|.. EventsSource

Updatable <|.. EventsDestination
Completable <|.. EventsDestination

Completing <|.. Future

Future <|-- Promise
Future <|-- ConstantFuture
Completable <|.. Promise

EventsSource <|.. Channel

Channel <|-- BaseProducer
EventsDestination <|.. BaseProducer

BaseProducer <|-- Producer
BaseProducer <|-- ProducerProxy

EventsDestination <|.. Sink

@enduml
